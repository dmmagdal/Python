# windows_wifi.py
# author: Diego Magdaleno
# In lieu of writing the script in a Windows compatible language such as batch,
# cmd, or powershell, this program will use the subprocess module to exectute
# and parse windows commands that should reveal the saved WiFi profile names
# and their passwords (where applicable). This can be expanded upon for later
# information gathering on a system's saved network information.
# Python 3.7
# Windows/MacOS/Linux


import json
import platform
import subprocess
from subprocess import PIPE


def main():
	# Check that this system is a windows machine.
	if platform.system() != "Windows":
		print("Error: Host does not run Windows OS. Exiting program.")
		exit(1)

	# Issue the following command to get the list of current wlan (WiFi)
	# profiles. Save the parsed results to a variable.
	view_profiles_cmd = subprocess.Popen("netsh wlan show profile",
						shell=True, stdout=PIPE)
	profile_output = view_profiles_cmd.communicate()[0].decode('utf-8')

	# Split the command output by line.	
	profile_output_lines = profile_output.split("\r\n")

	# Separate the output lines by group and user profiles. You can do this
	# by indexing the headers ("Group policy profiles (read only)" and
	# "User profiles").
	group_start = profile_output_lines.index("Group policy profiles" +\
						 " (read only)")
	user_start = profile_output_lines.index("User profiles") 
	group_profiles_lines = profile_output_lines[group_start:user_start]
	user_profiles_lines = profile_output_lines[user_start:]

	# For the Group profiles, if the "<None>" string is found in the second
	# line after the header, then there is no need to read the rest of the
	# lines. Otherwise, scan/parse the profiles listed.
	users, groups = {}, {}
	if "<None>" not in group_profiles_lines[2]:
		profiles = get_wlan_profiles(group_profiles_lines[2:])
		#print("groups", str(profiles))
		groups_data = []
		for profile in profiles:
			groups_data.append(parse_profile_data(profile))
		groups = {"Group Profiles": groups_data}
	
	# Same goes for the User profiles. 
	if "<None>" not in user_profiles_lines[2]:
		profiles = get_wlan_profiles(user_profiles_lines[2:])
		#print("users", str(profiles))
		users_data = []
		for profile in profiles:
			users_data.append(parse_profile_data(profile))
		users = {"User Profiles": users_data}

	# Write the data to a report json file.
	master = groups
	master.update(users)
	with open("Windows_WLAN_Report.json", "w+") as json_file:
		json.dump(master, json_file, indent = 4)

	# Exit the program.
	exit(0)


def get_wlan_profiles(profile_lines):
	""" Given the list of lines (str) from a wlan user group, obtain the
	    names of the saved wlan profiles, returned as a list of strings.
	"""
	
	# List of profiles found (variable to be returned).
	profile_names = []

	# For every line in the arguments list, split the string by the ":" to
	# isolate the profile name (the last entry of the resulting list) and
	# removing any unnecessary extra spaces. Append the profile name string
	# to the return list.
	for line in profile_lines:
		# Ignore blank lines.
		if line == "":
			continue
		name = line.split(":")[-1].lstrip(" ")
		profile_names.append(name)

	# Return the list.
	return profile_names


def parse_profile_data(profile_name):
	""" Given a wlan profile's name, run another windows command to get
	    more information (such as the plaintext password) on the profile
	    and return that information as a dictionary.
	"""
	
	# Dictionary of attributes for the profile name given.
	profile_attr = {}

	# Send the Windows command to get information on the specified profile.
	show_profile = "netsh wlan show profile "
	key_clear = " key=clear"
	profile_attr_cmd = subprocess.Popen(show_profile + profile_name +\
						key_clear, shell=True, 
						stdout=PIPE)
	profile_attr_output = profile_attr_cmd.communicate()[0].decode('utf-8')

	# Split the returned string by its new line character.
	profile_attr_lines = profile_attr_output.split("\r\n")

	# Verify that there are no empty results in regards to the profile. If
	# the results are empty (identified by the string on the first line of
	# the attributes lines returned by the windows command), return a blank
	# dictionary for the attributes.
	empty_results = "There is no such wireless interface on the system."
	if empty_results in profile_attr_lines[0]:
		return {}  

	# Set the scope of the profile (ie Applied: All User Profile) as
	# "Application".
	if "Applied:" in profile_attr_lines[4]:
		profile_attr["Application"] = profile_attr_lines[4]

	# Go through every line in the output. The first three lines are the
	# header/title of the output. The fourth/fifth line is for the scope of
	# the wlan profile (referenced above). After that, parse the content.
	tab = " " * 4
	for line in range(6, len(profile_attr_lines)):
		#print(line, profile_attr_lines[line])

		# For a file line. A header file is a file that doesn't start
		# with a tab (4 " " characters). Every header is followed by a
		# line of characters "-" that are as long as the header.
		if tab not in profile_attr_lines[line] and \
			"-" not in profile_attr_lines[line] and \
			profile_attr_lines[line] != "":
			header = profile_attr_lines[line]
			content = profile_attr_lines[line+2:]
	
			# Parse the data and save it in the dictionary. The key
			# is the header and the parsed data is the value.
			profile_attr[header] = parse(profile_attr_lines[line:])

	#print(json.dumps(profile_attr, indent=4))

	#return profile_attr

	return {"Profile": profile_name, "Report": profile_attr}


def parse(lines):
	""" Given the list of lines, parse the data into a dictionary and
	    return it.
	"""
	
	# Dictionary containing the data, now parsed as key, value pairs
	# instead of the original string representation.
	data_dict = {}

	# Find the stopping point for the section of data being parsed. In this
	# case, the stopping point is the first line that just contains a blank
	# string "". This can be accomplished using the index() function of the
	# list.
	section_end_index = lines.index("")

	#print(section_end_index)

	# Iterate from the beginning of the list of lines to the stopping point
	# found above.
	tab = " " * 4
	index = 0
	while index < section_end_index:
		#print(str(index), lines[index])
		# If there is a double "tab" in the line, then initialize a
		# sub-dictionary and store the data in there. The data here is
		# parsed similarly to the rest of the data. Append that sub-
		# dictionary to the data dictionary as a value.
		if index < len(lines) and str(tab + tab) in lines[index]:
			# Initialize the sub-directory and save the key to the
			# sub-directory. The key is "key" to the previous line.
			sub_dict = {}
			key = lines[index-1].split(":")[0].lstrip(" ")\
						.rstrip(" ")
			while str(tab + tab) in lines[index]:
				split_line = lines[index].split(":")
				key = split_line[0].lstrip(" ").rstrip(" ")
				value = split_line[-1].lstrip(" ").rstrip(" ")
				sub_dict[key] = value
				index += 1
			data_dict[key] = sub_dict
		# Otherwise, if there is just a single "tab" in the line, then
		# split the string on that line by the ":". The string in the
		# first index (of the resulting list) is the key. The string in
		# the last index (of the resulting list) is the value. Both the
		# key and values are cleaned of excess whitespace on either
		# side of the strings. These values are added to the
		# dictionary.
		if index < len(lines) and tab in lines[index]:
			split_line = lines[index].split(":")
			key = split_line[0].lstrip(" ").rstrip(" ")
			value = split_line[-1].lstrip(" ").rstrip(" ")
			data_dict[key] = value

		# Increment the iterator.
		index += 1

	# Return the now populated dictionary with the parsed data.
	return data_dict	


if __name__ == '__main__':
	main() 
