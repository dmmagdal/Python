# addressProperties.py
# author: Diego Magdaleno
# Simple python program that get's a host's (IPv4) address and breaks
# down the properties of that address.
# Python 3.7
# Windows/MacOS/Linux


import socket
import subprocess
import platform


def main():
	# Acquire the (IPv4) address with the socket module. First acquire
	# the host name, then get the local (public) address from that.
	host_name = socket.gethostname()
	print("Host Name: " + host_name)
	local_address = socket.gethostbyname(host_name)
	print("Local Address: " + local_address)

	# Break the address down into its octets. Then convert each octet
	# into binary. 
	octets = [bin(int(number)).replace("0b", "") for
				number in local_address.split(".")]

	# Be sure to clean up the binary for each octet. If an octet is
	# less than 8 characters long, then prepend the appropriate ammount
	# "0"s to the string.
	for i in range(len(octets)):
		octets[i] = format_octet(octets[i])
	print("Local Address in Binary: " + ".".join(octets))

	# Determine the class of the network based on the set bit in the
	# first octet.
	network_classes = {"A": "0", "B": "10", "C": "110", "D": "1110",
						"E": "1111"}
	first_octet = octets[0]
	network_class = ""
	for net_class in network_classes:
		bit_range = len(network_classes[net_class])
		if first_octet[:bit_range] == network_classes[net_class]:
			network_class = net_class
			print("Network Class: " + net_class)
			break
	
	# If the address is not a part of any of the five standard network
	# classes, exit the program. This should be impossible but is still
	# a good error check.
	if network_class == "":
		print("Network is not a part of any of the standard classes.")
		exit(0)

	# Get the subnet mask. Print it if one was found, otherwise, print
	# a different string and exit the program.
	subnet_mask = get_subnet(platform.system(), local_address)
	if subnet_mask != "":
		print("Subnet Mask: " + subnet_mask)
	else:
		print("Subnet Mask: No Subnet Mask Was Found")
		exit(0)

	# Convert the subnet mask to bits. Remember to fill in for any
	# leading zeroes missing like you did with the IPv4 address.
	subnet_octets = [bin(int(number)).replace("0b", "") for
					number in subnet_mask.split(".")]
	for index in range(len(subnet_octets)):
		subnet_octets[index] = format_octet(subnet_octets[index])
	print("Subnet Mask in Binary: " + ".".join(subnet_octets))

	# Write the subnet mask in short hand (prefix length). It's easier
	# to do this with the subnet mask in binary form. Just count the 
	# number of (leading) 1's (ones).
	full_subnet_binary_string = "".join(subnet_octets)
	subnet_short_hand = "/" + str(full_subnet_binary_string.count("1"))
	print("Subnet Mask in Short-hand: " + subnet_short_hand)

	# Get the network/subnetwork identifier (prefix) of the (IPv4)
	# address. Print out the result in both integer and binary.
	net_identifier_octets = []
	net_identifier_binary_octets = []
	for o in range(4):
		# Perform a bitwise AND on the binary of each octet.
		address_octet = int(local_address.split(".")[o])
		subnet_octet = int(subnet_mask.split(".")[o])
		anded_octet = address_octet & subnet_octet

		# Make sure that the string for the binary are properly
		# formatted.
		anded_octet_binary = format_octet(bin(anded_octet).lstrip("0b"))
		# if len(anded_octet_binary) < 8:
		# 	prepend_zeroes = "0" * (8 - len(anded_octet_binary))
		# 	anded_octet_binary = prepend_zeroes + anded_octet_binary

		# Append the octet to their respective lists.
		net_identifier_octets.append(str(anded_octet))
		net_identifier_binary_octets.append(anded_octet_binary)
	print("Network/Subnetwork Identifier: " + ".".join(net_identifier_octets))
	print("Network/Subnetwork Identifier in Binary: " + 
			".".join(net_identifier_binary_octets))
	print("Address " + local_address + " belongs to the subnet " +
			".".join(net_identifier_octets) + subnet_short_hand)

	# Print out the number of available hosts on the subnet.
	possible_hosts_bits = 32 - int(subnet_short_hand.lstrip("/"))
	possible_hosts = 2** possible_hosts_bits
	print("Possible Number of Hosts on This Subnetwork: " +
			str(possible_hosts))

	# Find the subnet broadcast address and print it in both integer
	# and binary form. Start by finding the compliment (inversion) of
	# the subnet mask octets (in binary).
	compliment_mask_binary = []
	for subnet_octet in subnet_octets:
		compliment_mask_binary.append(binary_compliment(subnet_octet))
	compliment_mask = address_to_int(compliment_mask_binary)
	print("Subnet Mask Compliment: " +
			".".join(compliment_mask))
	print("Subnet Mask Compliment in Binary: " +
			".".join(compliment_mask_binary))

	# Then, OR the compliment of the subnet mask with the ip address.
	subnet_broadcast_address = []
	address_octets = local_address.split(".")
	for octet in range(len(compliment_mask)):
		sba_octet = int(compliment_mask[octet]) | int(address_octets[octet])
		subnet_broadcast_address.append(str(sba_octet))
	print("Subnet Broadcast Address: " + ".".join(subnet_broadcast_address))

	# Exit the program.
	exit(0)


def get_subnet(operating_system, local_address):
	""" Given the operating system of the host machine and the local
		(IPv4) address, return the subnet mask as a string.
	"""
	
	# For Windows based hosts, issue the "ipconfig" command through the
	# subprocess module and parse the output to get the subnet mask.
	if operating_system == "Windows":
		cmd = subprocess.Popen("ipconfig", shell=True, stdout=subprocess.PIPE)
		cmd_output = cmd.communicate()[0].decode("utf-8")
		cmd_output_lines = cmd_output.split("\r\n")

		for index in range(len(cmd_output_lines)):
			line = cmd_output_lines[index]
			if "IPv4 Address" in line and local_address in line:
				subnet_line = cmd_output_lines[index+1]
				split_line = subnet_line.split(":")
				subnet_mask = split_line[-1].lstrip(" ").rstrip("\r\n")
				return subnet_mask
	# For MacOS and Linux hosts, issue the "ifconfig" comand through
	# the subprocess module and parse the output to get the subnet mask
	# (similar to Windows but parsing will be a bit different).
	else:
		cmd = subprocess.Popen("ifconfig", shell=True, stdout=subprocess.PIPE)
		cmd_output = cmd.communicate()[0].decode("utf-8")
		cmd_output_lines = cmd_output.split("\n")

		for index in range(len(cmd_output_lines)):
			line = cmd_output_lines[index]
			if "inet" in line and local_address in line:
				subnet_line = cmd_output_lines[index]
				split_line = subnet_line.split("netmask ")[-1].split(" ")
				subnet_mask = split_line[0]
				return subnet_mask		
		return ""

	# Otherwise, return a blank string (no submask was found).
	return ""


def format_octet(binary_octet):
	""" Take a binary string and prepend zeroes to it so that the
		string is 8 characters long (the appropriate length of an
		octet). Return a properly formated binary string 8 characters
		long.
	"""

	# If the binary string is less than 8 characters long, prepend
	# the appropriate amount of zeroes to the string.
	if len(binary_octet) < 8:
		prepend_zeroes = "0" * (8 - len(binary_octet))
		binary_octet = prepend_zeroes + binary_octet

	# Return the properly formated binary string.
	return binary_octet


def octet_to_binary(octet):
	""" Convert an octet from an IPv4 address to its binary value. Make
		sure that its returned with the appropriate amount of bits (8).
	"""

	# Return the binary of the octet's integer value. Remember to
	# remove the "0b" prefix at the beginning of the string and then
	# format it.
	return str(format_octet(bin(octet).lstrip("0b")))


def octet_to_int(octet):
	""" Convert an octet from an IPv4 address to its integer value. Make
		sure that its returned with the appropriate amount of bits (8).
	"""

	# Return the binary of the octet's integer value. Remember to
	# remove the "0b" prefix at the beginning of the string and then
	# format it.
	return str(int(format_octet(octet), 2))


def address_to_binary(address):
	""" Given an address (either as a list or a string) in integer
		form, convert the address to binary (as the same type as the
		argument).
	"""

	# Flag that will be used to determine if the addressed is to be
	# returned as a list or string.
	is_str = False

	# Check the address argument to make sure it is a list or string.
	# If it is neither of these, return a blank string.
	if not isinstance(address, str) and not isinstance(address, list):
		return ""
	elif isinstance(address, str):
		# In the event that the address is a string, set the is_str
		# flag to True and split the string by "." so that it creates
		# a list of octets (there should be 4 octets in the list).
		is_str = True
		split_address = address.split(".")

		if len(split_address) != 4:
			# If the resulting list does not contain 4 octets, return
			# a blank string.
			return ""
	else:
		# Otherwise, the address is a list, verify that it contains 4
		# octets. If it does not, return a blanks string.
		split_address = list(address)

		if len(split_address) != 4:
			return ""

	# Iterate through the list. Convert every octet to binary and
	# overwrite the integer value in that position.
	for octet in range(len(split_address)):
		split_address[octet] = octet_to_binary(split_address[octet])

	# If the address was flagged as a string, return it as a string. 
	if is_str:
		return ".".join(split_address)

	# Otherwise, return the address as a list.
	return split_address


def address_to_int(address):
	""" Given an address (either as a list or a string) in binary
		form, convert the address to integer (as the same type as the
		argument).
	"""

	# Flag that will be used to determine if the addressed is to be
	# returned as a list or string.
	is_str = False

	# Check the address argument to make sure it is a list or string.
	# If it is neither of these, return a blank string.
	if not isinstance(address, str) and not isinstance(address, list):
		return ""
	elif isinstance(address, str):
		# In the event that the address is a string, set the is_str
		# flag to True and split the string by "." so that it creates
		# a list of octets (there should be 4 octets in the list).
		is_str = True
		split_address = address.split(".")

		if len(split_address) != 4:
			# If the resulting list does not contain 4 octets, return
			# a blank string.
			return ""
	else:
		# Otherwise, the address is a list, verify that it contains 4
		# octets. If it does not, return a blanks string.
		split_address = list(address)

		if len(split_address) != 4:
			return ""

	# Iterate through the list. Convert every octet to integer and
	# overwrite the binary value in that position.
	for octet in range(len(split_address)):
		split_address[octet] = octet_to_int(split_address[octet])

	# If the address was flagged as a string, return it as a string. 
	if is_str:
		return ".".join(split_address)

	# Otherwise, return the address as a list.
	return split_address


def address_to_string(address_octets):
	""" Take a list of (4) octets (strings) for an address and return
		the concatenation of those octets with "." in between them. The
		end result should look something like this:
			address of integers: "XXX.XXX.XXX.XXX"
			address of binary: "YYYYYYYY.YYYYYYYY.YYYYYYYY.YYYYYYYY" 
	"""

	# Take the list and use the join() method with the "." to
	# concatentate the elements into one string.
	return ".".join(address_octets)


def binary_compliment(octet):
	""" Take an octet (in binary) and retrieve the compliment of the
		binary. Return the compliment in binary.
	"""

	# Create an empty string to store the binary compliment of the 
	# octet.
	compliment = ""

	# Iterate through the binary in the original octet. For every
	# position in the string (should be 8 bits if we assume that the
	# octet fed as an argument is formatted correctly), append the
	# compliment to the return binary.
	for i in range(len(octet)):
		if octet[i] == "1":
			compliment += "0"
		else:
			compliment += "1"

	# Return the compliment.
	return compliment


if __name__ == '__main__':
	main()
