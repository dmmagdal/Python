# ftpsshclient.py
# author: Diego Magdaleno
# Simple program that doubles as a ftp and ssh client.
# Python 3.6
# Linux


import sys
import os
import paramiko
import ftplib


def main():
	# Detect command line arguments. Check for correct mode.
	if not checkArgs():
		print("Error: Usage python ftpsshclient.py <mode> <args>")
		exit(1)

	# Set mode.
	mode = sys.argv[1]

	# Error string for command line invalid arguments.
	err1 = "Error: Arguments for sftp mode are"
	err11 = "Error: Arguments for ssh mode are"
	err2 = " <hostname> <username> <password> <port>(optional)"

	# Given mode, check for correct arguments.
	if mode == "sftp" and not checkSTFPArgs():
		print(err1 + err2)
		exit(1)
	elif mode == "ssh" and not checkSSHArgs():
		print(err11 + err2)
		exit(1)

	# Depending on mode, run in one of the two modes.
	if mode == "sftp":
		runSFTP()
	elif mode == "ssh":
		runSSH()

	# Close the program.
	exit(0)

# Check the cmd args for the modes (and for length of the arguments).
def checkArgs():
	if len(sys.argv) < 3:
		return False
	elif sys.argv[1] != "sftp" and sys.argv[1] != "ssh":
		return False


# Check the remaining cmd args for sftp mode.
def checkSFTPArgs():
	sftpArgs = sys.argv[2:]
	if len(sftpArgs) != 3:
		return False
	return True


# Check the remaining cmd args for ssh mode.
def checkSSHArgs():
	sshArgs = sys.argv[2:]
	if len(sshArgs) != 3:
		return False
	return True


# Run the sftp client.
def runSFTP():
	# Store args from cmd.
	host = sys.argv[2]
	name = sys.argv[3]
	passw = sys.argv[4]
	port = None
	if len(sys.argv) == 6:
		port = int(sys.argv[5])

	# Connect to host.
	client = ftplib.FTP()
	client.connect(host=host, port=port)
	client.get_welcome()
	client.login(user=name, password=passw)

	# Close the connection.
	client.close()
	return


# Run the ssh client.
def runSSH():
	# Store args from cmd.
	host = sys.argv[2]
	name = sys.argv[3]
	passw = sys.argv[4]
	port = None
	if len(sys.argv) == 6:
		port = int(sys.argv[5])

	# Connect to host.
	client = paramiko.SSH_Client()
	client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
	client.connect(host=host, user=name, password=passw, port=port)

	# Infinite loop for the user to enter multiple commands per
	# session.
	while True:
		# Take input from user.
		cmd = input("$: ")

		# Check if the user wants to close the connection, check their
		# input.
		if cmd == exit:
			break
		
		# Store the results of their command in the tuple. Each
		# variable is a file descriptor. You must readlines() to
		# access its contents.
		stdin, stdout, stderr = client.exec_command(cmd)

		# Print out results of command.
		if len(stdout.readlines()) != 0:
			print(stdout.readlines())
		if len(stderr.readlines()) != 0:
			print(stderr.readlines())
	
	# Close client connection.
	client.close()
	return


# Run the sftp client through paramiko.
def paramikoFTP():
	# Store args from cmd.
	host = sys.argv[2]
	name = sys.argv[3]
	passw = sys.argv[4]
	port = None
	if len(sys.argv) == 6:
		port = int(sys.argv[5])

	# Connect to host.
	client = paramiko.SSH_Client()
	client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
	client.connect(host=host, user=name, password=passw, port=port)

	# Create ftp object.
	ftp = client.open_sftp()

	# Infinite loop in case the user wants to push multiple files in
	# one session.
	while True:
		# Transfer command string.
		trnfrStr1 = "Enter filepaths as well as a mode: \n"
		trnfrStr2 = "<pull, push> <filepath1> <filepath2> \n Or "
		trnfrStr3 = "type \'exit\' to quit."

		# Transfer files.
		fileArgs = input(trnfrStr1 + trnfrStr2 + trnfrStr3).split(" ")
		
		# If the first input of the string is "exit", quite the loop.
		if fileArgs[0] == "exit":
			break

		# Otherwise, check the split string. Are there correct number
		# of arguments?
		if len(fileArgs) != 3:
			# If not, print an error message and restart the loop.
			print("Error: Invalid input. Check your arguments")
			continue

		# Otherwise, load the commands to variables.
		mode = fileArgs[0]
		filepath1 = fileArgs[1]
		filepath2 = fileArgs[2]

		# Check the transfer mode.
		if mode == "pull":
			# Pull mode means that filepath1 is the remote file path and
			# filepath2 is the local filepath. We are getting something
			# from the remote computer.
			ftp.get(filepath1, filepath2)
		elif mode == "push":
			# Pull mode means that filepath1 is the local file path and
			# filepath2 is the remote filepath. We are putting something
			# from the local computer onto the remote computer.
			ftp.put(filepath1, filepath2)
		else: 
			# Error string for invalid ftp mode.
			err1 = "Error: Invalid mode. Either type push or pull"
			err2 = " for the mode."
			print(err1 + err2)
	
	# Close the ftp connection.
	ftp.close()
	return


if __name__ == '__main__':
	main()
