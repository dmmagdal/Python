# network1-4-1.py
# scans the local network and creates a graph of all devices connected 
# to the network
#
# note: This is best run from command prompt (windows) or terminal (linux/mac)
#
# Changes:	added multiprocessing to try to cut down on time
#			also reduced the number of pings to 2 to reduce time
#			results in not using tqdm module for lack of accurate progress tracking

import subprocess, ipaddress
import socket, os, re, platform
import time
import networkx as nwtk
import matplotlib as plt
from tqdm import tqdm
import multiprocessing as mp

# function that pings a list of addresses
def pingAddr(hostIp, onlineDevs, info):
	print(info)
	if os.name == "posix":
		output = subprocess.Popen(['ping -c 2 ' + str(hostIp)], 
				stdout = subprocess.PIPE, shell = True).communicate()[0]
	elif platform.system() == "Windows" and info != 0:
		output = subprocess.Popen(['ping', '-n 2', str(hostIp)], 
				stdout = subprocess.PIPE, shell = True, startupinfo = info).communicate()[0]

	if platform.system() == "Windows" and "Destination host unreachable" not in output.decode('utf-8') and "Request timed out" not in output.decode('utf-8'):
		onlineDevs.append(str(hostIp))
	elif os.name == "posix" and "Destination Host Unreachable" not in output.decode('utf-8') and "errors" not in output.decode('utf-8'):
		onlineDevs.append(str(hostIp))

	return onlineDevs

# draw network as a graph
def graphResults(onlineDevs, defaltGtStr):
	G = nwtk.Graph()
	G.add_nodes_from(onlineDevs)
	for node in onlineDevs:
		if node != defaltGtStr:
			edge = (defaltGtStr, node)
			G.add_edge(*edge)
	nwtk.draw(G, with_labels = True, font_weight = "bold")
	plt.pyplot.show()

# calculate final time it took for program to execute
def calcEndTime(start, end):
	seconds = round(end - start, 2)
	hours = int(seconds // 3600)
	seconds -= hours*3600
	minutes = int(seconds // 60)
	seconds -= minutes*60
	seconds = round(seconds, 2)
	if hours != 1:
		hoursString = str(hours)+" hours"
	else:
		hoursString = str(hours)+" hour"
	if minutes != 1:
		minutesString = str(minutes)+" minutes"
	else:
		minutesString = str(minutes)+" minute"
	if seconds != 1.00:
		secondsString = str(seconds)+" seconds"
	else:
		secondsString = str(seconds)+" second"
	returnString = hoursString+" "+minutesString+" "+secondsString+"."
	return returnString

# convert subnet mask into CIDR format
def convert2CIDR(subnetMask):
	octets = subnetMask.split(".")
	#print(octets)
	binOctets = []
	for oc in octets:
		#binOctets.append(bin(int(oc))[2:])
		binOctets.append(format(int(oc), "08b"))
	#print(binOctets)
	# sum up all occurances of 1 to find subnet mask int value
	fusedBinOct = binOctets[0] + binOctets[1] + binOctets[2] + binOctets[3]
	return "/"+str(fusedBinOct.count("1"))

# main function
def main():
	# start timer
	start = time.time()

	# retrieve device's ipaddress
	s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
	s6 = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
	s.connect(('google.com', 0))
	s6.connect(('google.com', 0))
	ip = s.getsockname()[0]
	ip6 = s6.getsockname()[0]
	end = re.search('^[\d]{1,3}.[\d]{1,3}.[\d]{1,3}.[\d]{1,3}', ip)
	end6 = re.search('^[\d]{1,3}.[\d]{1,3}.[\d]{1,3}.[\d]{1,3}.[\d]{1,3}.[\d]{1,3}', ip6)
	print("IPv4 Address "+str(end.group(0)))
	print("IPv6 Address "+str(end6.group(0)))

	#print(type(end.group(0)))
	#print(end.group(0))

	#ip = input("Enter a network address in CIDR format(ex.192.168.1.0/24): ")

	subnetMask = ""
	defaltGt = []

	if os.name == "posix":
		# if you're on a unix based OS (Mac included)
		os.system("ifconfig > wifi.txt")
		# enter file and retrieve subnet mask
		wifi = open("wifi.txt", "r")
		lines = wifi.readlines()
		subnetMaskStr = ""
		# set up the wireless variable
		wirelessName = ""
		# find network hardware on machine and add it to a list
		os.system("lshw -short > hw.txt")
		hw = open("hw.txt", "r")
		hwlines = hw.readlines()
		networkDev = []
		for i in range(len(hwlines)):
			hwlines[i] = hwlines[i].split("\n")[0]
			if "network" in hwlines[i]:
				networkDev.append(hwlines[i])
		#print(networkDev)
		for j in range(len(networkDev)):
			networkDev[j] = networkDev[j].split()[1]
			#print(networkDev[j])
		for line in range(len(lines)):
			for device in networkDev:
				if device in lines[line] and "inet" in lines[line + 1]:
					addressLine = lines[line + 1]
					#print(addressLine)
					subnetMask = addressLine.split("Mask:")[1].strip("\n")
		print("Subnet Mask", subnetMask)
		# retrieve default gateway (IPv4)
		os.system("ip r > default.txt")
		default = open("default.txt", "r")
		deflines = default.readlines()
		defaultLine = deflines[0].split("dev")[0]
		defaltGtStr = defaultLine.split()[len(deflines) - 1]
		print("Default Gateway", defaltGtStr.split('\n'))

		# close and delete file (no longer need it)
		wifi.close()
		hw.close()
		default.close()
		os.remove("wifi.txt")
		os.remove("hw.txt")
		os.remove("default.txt")

	elif platform.system() == "Windows":
		# if you're on a windows based OS
		os.system("ipconfig > wifi.txt")
		# enter file and retrieve subnet mask
		wifi = open("wifi.txt", "r")
		lines = wifi.readlines()
		subnetMaskStr = ""
		#for line in lines:
		#	if "Subnet Mask" in line:
		#		subnetMaskStr = line
		#	if "Default Gateway" in line:
		#		defaltGt.append(line)
		#		defaltGt.append(line+1)
		for i in range(len(lines)):
			if "Subnet Mask" in lines[i]:
				subnetMaskStr = lines[i]
			if "Default Gateway" in lines[i]:
				defaltGt.append(lines[i])
				defaltGt.append(lines[i+1])
		subnetMskStrLs = subnetMaskStr.split(":")
		nextString = subnetMskStrLs[1].split("\n")
		subnetMask = nextString[0].split()[0]
		#print(type(subnetMask))
		print("Subnet Mask", subnetMask)
		# retrieve default gateway (IPv4)
		defaltGtStr = defaltGt[1].split()[0]
		defaltGtStr1 = defaltGtStr.split("\n")
		print("Default Gateway", defaltGtStr1)

		# close and delete file (no longer need it)
		wifi.close()
		os.remove("wifi.txt")

	sNMask = convert2CIDR(subnetMask)

	print("Subnet Mask in CIDR", sNMask)

	print("IPv4 in CIDR:", end.group(0)+sNMask)

	# create network
	ip_net = ipaddress.ip_network(end.group(0)+sNMask, strict = False)
	# set strict = false to
	#ip_net = ipaddress.ip_network(ip)

	#print(ip_net)
	#print(ip_net.hosts())

	# get all hosts on network
	all_hosts = list(ip_net.hosts())
	#print(all_hosts[:9999])

	# assign info variable so it can be passed into the pingAddr function
	# even if the OS is not Windows
	#info = 0

	# configure subprocess to hide console window
	if platform.system() == "Windows":
		info = subprocess.STARTUPINFO()
		info.dwFlags |= subprocess.STARTF_USESHOWWINDOW
		info.wShowWindow = subprocess.SW_HIDE
	else:
		info = 0

	print("There are", len(all_hosts)-1, "available hosts on the network")

	onlineDevs = []

	'''
	# for each ip address in the subnet
	# run the ping command with subprocess.popen interface
	#for i in range(len(all_hosts)):
	for i in tqdm(range(len(all_hosts))):
		#output = subprocess.Popen(['ping', '-n', '1', 'w', '500', str(all_hosts[i])], 
		#		stdout = subprocess.PIPE, startupinfo = info).communicate()[0]
		if os.name == "posix":
			output = subprocess.Popen(['ping -c 4 ' + str(all_hosts[i])], 
					stdout = subprocess.PIPE, shell = True).communicate()[0]
		elif platform.name() == "Windows":
			output = subprocess.Popen(['ping', str(all_hosts[i])], 
					stdout = subprocess.PIPE, startupinfo = info).communicate()[0]

		#if "Destination host unreachable" in output.decode('utf-8'):
		#	print(str(all_hosts[i]), "is Offline")
		#elif "Request timed out" in output.decode('utf-8'):
		#	print(str(all_hosts[i]), "is Offline")
		#else:
		#	print(str(all_hosts[i]), "is Online")
		#	onlineDevs.append(str(all_hosts[i]))
		print(output.decode('utf-8'))
		# add devices for Windows system
		if platform.system() == "Windows" and "Destination host unreachable" not in output.decode('utf-8') and "Request timed out" not in output.decode('utf-8'):
			onlineDevs.append(str(all_hosts[i]))
		# add devices for linux based systems
		elif os.name == "posix" and "Destination Host Unreachable" not in output.decode('utf-8') and "errors" not in output.decode('utf-8'):
			onlineDevs.append(str(all_hosts[i]))
		#if "Destination Host Unreachable" in output.decode('utf-8'):
		#	print("Dest Host Unreahable = True")
	'''
	jobs = []
	for i in tqdm(range(len(all_hosts))):
		p = mp.Process(target = pingAddr, args = (all_hosts[i], onlineDevs, info))
		p.start()
		jobs.append(p)
	for j in jobs:
		j.join()



	print("\nThere are", len(onlineDevs), "devices Online\n")

	for activeDev in onlineDevs:
		print(activeDev)

	if defaltGtStr in onlineDevs:
		print("Default Gateway in list of Online devices")
		print("Default Gateway:", defaltGtStr)

	end = time.time()
	final = calcEndTime(start, end)
	print("Program finished in", final)

	graphResults(onlineDevs, defaltGtStr)
	exit(0)

if __name__ == "__main__":
	main()