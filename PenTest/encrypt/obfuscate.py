# obfuscate.py
# author: Diego Magdaleno
# This program breaks a file down into its characters and stores them
# in a dictionary where their values are a list of indices.
# Python 3.6
# Linux


import sys
import os
import re


def main():
	# Variables to be set for operations.
	debug = False
	obfu = False
	clari = False
	numFiles = 0

	#debugM("Outside of checking sys args.")

	# Check the cmd args to see if there is proper usage when running
	# the program.
	if not checkSysArgs():
		printErrorMsg()

	#debugM("Sys args are valid. Going on to load options.")

	# Check the usage arguments and set operation variables.
	usage = sys.argv[1]
	if usage == "-h":
		printHelpMsg()
		exit(0)
	if "o" in usage:
		obfu = True
	if "c" in usage:
		clari = True
	if "d" in usage:
		debug = True
	options = [debug, obfu, clari]

	if debug:
		debugM("usage", usage)
		debugM("options", options)

	# Go file by file in the arguments, performing the appropriate
	# operations for each.
	numFiles = len(sys.argv) - 2
	if debug:
		debugM("Number of files", numFiles)
	for i in range(numFiles):
		file = sys.argv[2+i]
		if debug:
			debugM("File", file)
		operate(file, options)

	# Program is finished. Exit.
	exit(0)


# Check to make sure the proper starting arugments exist within the 
# cmd args.
# @param, takes no arguments.
# @return, returns a boolean (True) if all arguments are correct. False
#	otherwise.
def checkSysArgs():
	if "-" not in sys.argv[1]:
		return False
	elif "o" in sys.argv[1] and "c" in sys.argv[1]:
		return False
	elif "o" in sys.argv[1] and "h" in sys.argv[1]:
		return False
	elif "c" in sys.argv[1] and "h" in sys.argv[1]:
		return False
	elif "h" in sys.argv[1] and "d" in sys.argv[1]:
		return False
	elif "h" not in sys.argv[1] and len(sys.argv) < 3:
		return False
	return True


# Print an error message to the console. This is the default error
#	message. Program exits afterwards.
# @param, takes no arguments.
# @return, returns nothing.
def printErrorMsg():
	usageStr = "\'python obfuscate.py -h \'"
	print("Error: For proper usage of this program, type"+usageStr)
	exit(1)


# Print a message to help users understand how to use the program.
# @param, takes no arguments.
# @return, returns nothing.
def printHelpMsg():
	l1 = "Usage: python obfuscate.py -ocdh <target file(s)>"
	l2 = "\n\n -o to encrypt the targeted file(s)."
	l3 = "\n -c to decrypt the targeted file(s)."
	l4 = "\n -h to call help on usage of this program."
	l5 = "\n -d to enter debug mode (for developers only)."
	l6 = "\n\nThis program encrypts a file by breaking its contents "
	l7 = "\ndown into its characters and storing them in a dictionary "
	l8 = "\nwhere their values are a list of coordinates for where the"
	l9 = "\ncharacter was found in the original file. The file is"
	l10 = "\ndecrypted by reconstructing the contents through the"
	l11 = "\ncharacters and their associated coordinates."
	print(l1+l2+l3+l4+l5+l6+l7+l8+l9+l10+l11)


# Perform the desired operation on a file.
# @param, file: the file that needs to be operated on.
# @param, options: a tuple that contains variables detailing the
# 	options of the operation.
# @return, returns nothing. 
def operate(file, options):
	# Check if file exists.
	if not fileExists(file):
		print("Error: File does not exist in current path.")
		return

	# Check debug flag in options.
	if options[0]:
		debugM("File exists")

	# Check the operations.
	if options[1] == True:
		if options[0]:
			debugM("Program selected obfuscate")
		# Enter obfuscation mode.
		obfuscate(file, options[0])
	elif options[2] == True:
		if options[0]:
			debugM("Program selected clarify")
		# Enter clarification mode.
		clarify(file, options[0])


# Checks if a path to a file exists.
# @param, file: the path string to a file.
# @return, returns a boolean (True) if the path leads to a file. False
#	otherwise.
def fileExists(file):
	return os.path.exists(file) and os.path.isfile(file)


# Re write the file so that it is encrypted.
# @param, file: the path string to a file.
# @param, debugFlag: the flag for whether debug mode is engaged or not.
# @return, returns nothing.
def obfuscate(file, debugFlag):
	# Open file and load its contents to memory.
	lines = load(file)
	if debugFlag:
		debugM("file contents", lines)

	# Create a dictionary variable.
	charDict = dict()

	# Iterate through each line. Store characters to dictionary along
	# with their positions.
	for i in range(len(lines)):
		line = lines[i]
		# Iterate through the entire line string.
		for j in range(len(line)):
			char = line[j]
			if char not in charDict.keys():
				# If character never existed in the dictionary, store
				# the character as a new key and store a blank list as
				# its value. Then append the coordinates to the list.
				charDict[char] = list()
				charDict[char].append([i, j])
			else:
				# Otherwise, the character already exists as a key in
				# the dictionary. Append the coordinates to the list
				# stored as its value.
				charDict[char].append([i, j])

	if debugFlag:
		debugM("Dictionary", charDict)

	# Write dictionary to contents list.
	contents = list()
	for k in charDict:
		# Contents writtend as key (character) value (list).
		contents.append([k, charDict[k]])

	if debugFlag:
		debugM("Writing contents", contents)

	# Open file and re write its contents.
	save(file, contents)


# Re write the file so that it is decrypted. Note: this assumes that
# the file was encryped with this same program and therefore follows
# the "correct format".
# @param, file: the path string to a file.
# @param, debugFlag: the flag for whether debug mode is engaged or not.
# @return, returns nothing.
def clarify(file, debugFlag):
	# Open file and load its contents to memory.
	lines = load(file)

	# Find the max height and width of the "original" file.
	maxHeight = findMax(lines, 0)
	maxWidth = findMax(lines, 1)

	if debugFlag:
		debugM("maxHeight", maxHeight)
		debugM("maxWidth", maxWidth)

	# Create a maxHeight x maxWidth array of "" (empty strings) for the
	# unscrambled data.
	newLines = list()
	for i in range(maxHeight):
		line = list()
		for j in range(maxWidth):
			line.append("")
		newLines.append(line)
		if debugFlag:
			debugM("line", line)
	if debugFlag:
		debugM("empty array", newLines)

	# Iterate through each line of the contents. For each character,
	# read the associated list of coordinates and store them in the
	# array.
	row = 0
	while row in range(len(lines)):
		# Store the list in a variable.
		charCoords = lines[row]
		# If the length of the list is greater than 1, this is a normal
		# entry.
		if len(charCoords) > 1:
			# Store the char to be written.
			char = charCoords[0]
			#print(char)
			# Store the coordinates for the char (the remainder of the
			# list).
			coordDict = charCoords[1:]
			# Strip the non-numberics from the list. Store the result.
			dictString = re.sub(r'\D', ' ', coordDict)
			# Remove all whitespace, then remove all the empty strings
			# from the list. Store the resulting list.
			numbersList = removeAll(dictString.split(" "), "")
			# Iterate through the list. At each coordinate listed,
			# place the char in that position in the empty array.
			value = 0
			while value in range(len(numbersList)-1):
				# The x coordinate will be the first value in the index
				# while the y coordinate will be the value + 1.
				xcoord = int(numbersList[value])
				ycoord = int(numbersList[value+1])
				#print(str(xcoord)+", "+str(ycoord))
				# Write the char to the coordinates.
				newLines[xcoord][ycoord] = char
				# Increment the value by 2 to skip over the y
				# coordinate already stored.
				value += 2

		# Otherwise, this row contains the newline character ("\n").
		# This is a special case where the character does not have its
		# coordinates on the same row.
		else:
			# The char to be written is "\n".
			char = "\n"
			#print(char)
			# Store the coordinates for the char (the list on the next
			# line).
			coordDict = lines[row+1]
			# Strip the non-numberics from the list. Store the result.
			dictString = re.sub(r'\D', ' ', coordDict)
			# Remove all whitespace, then remove all the empty strings
			# from the list. Store the resulting list.
			numbersList = removeAll(dictString.split(" "), "")
			# Iterate through the list. At each coordinate listed,
			# place the char in that position in the empty array.
			value = 0
			while value in range(len(numbersList)-1):
				# The x coordinate will be the first value in the index
				# while the y coordinate will be the value + 1.
				xcoord = int(numbersList[value])
				ycoord = int(numbersList[value+1])
				#print(str(xcoord)+", "+str(ycoord))
				# Write the char to the coordinates.
				newLines[xcoord][ycoord] = char
				# Increment the value by 2 to skip over the y
				# coordinate already stored.
				value += 2
			# Increment the rwo value to not double store the
			# coordinate values for the newline character.
			row += 1
		row += 1

	if debugFlag:
		debugM("newLines", newLines)

	# Re structure the array so that it becomes a list of strings.
	content = list()
	for item in range(maxHeight):
		lineString = ""
		for char in newLines[item]:
			lineString += str(char)
		content.append(lineString)
		if debugFlag:
			debugM("lineString", lineString)

	if debugFlag:
		debugM("Writing contents", content)

	# Open file and re write its contents.
	save(file, content)


# Open file and load its contents to memory.
# @param, file: the path string to a file.
# @return, returns a list of lines that contains the files contents.
def load(file):
	# Open file and load its contents to memory.
	openFile = open(file, "r")
	lines = openFile.readlines()
	# Once contents are loaded, close the file and return the contents
	# (a list of strings).
	openFile.close()
	return lines


# Open file and re write its contents.
# @param, file: the path string to a file.
# @param, contents: a list of lines that are to be written to the file.
# @return, returns nothing.
def save(file, contents):
	# Open file and iterathe through contents to be written.
	openFile = open(file, "w")
	for line in contents:
		#debugM(None, line)
		# If the contents are lists (this is from obfuscation mode),
		# Then iterate through the list and write it to file.
		if isinstance(line, list):
			#debugM("Writing list as line")
			for item in line:
				openFile.write(str(item))
				#print(item)
			openFile.write("\n")
		# Otherwise, the contents are reconstructed strings to be
		# written back to the file.
		else:
			#debugM("Writing string in line")
			openFile.write(line)
	# Writing is complete, close file.
	openFile.close()
	#debugM("File saved")


# A method handy for printing debug statements.
# @param, string: default is None. Holds the string that is to be
#	printed to console.
# @param, items: default is None. Holds the items that are to be
#	printed to the console.
# @return, returns nothing
def debugM(string=None, items=None):
	# Print a string if there is one.
	if string != None:
		print(string)
	# Print the items and their type is there is one.
	if items != None:
		print(type(items))
		print(items)
	# Print a newline character to console for spacing if at least
	# one of the arguments is not None.
	if string != None or items != None:
		print("\n")
	# Otherwise, print nothing.


# Find the maximum width/ height of the unencrypted file given the
# lines from the file in its encrypted state. These lines should 
# match a dictionary format.
# @param, lines: the lines from the file in their encrypted state.
# @param, index: the value that corresponds to the coordinate we're
#	testing for. 0 is for i (height), 1 is for j (width).
# @return, returns an integer that is the maximum width/ height of 
#	the unencrypted file.
def findMax(lines, index):
	# Initialize return variable.
	maxVal = 0
	# Iterate through each line.
	for line in lines:
		# Use this condition to skip "blank" lines that only contain
		# "\n".
		if len(line) > 1:
			# Replace all the non-numerics from the line string with
			# whitespace.
			dictString = re.sub(r'\D', ' ', line)

			# Turn the now modified string into a list, parsed by
			# whitespace.
			listOfNumbers = dictString.split(" ")
			#debugM("listOfNumbers", listOfNumbers)

			# Create a short list out of the current one (This should
			# remove the character key and the first " " in the string
			# that represents the beginning of the dictionary). 
			shortListOfNumbers = listOfNumbers[2:]
			#debugM("shortListOfNumbers", shortListOfNumbers)

			# Now, all that remain in the list are "" (empty strings)
			# and numbers. The "" (empty strings) are to be removed,
			# leaving only the numbers in the list. There should be an
			# even amount of numbers.
			shortListOfNumbers = removeAll(shortListOfNumbers, "")
			#debugM("shortListOfNumbers", shortListOfNumbers)
			#debugM("length of shortList", len(shortListOfNumbers))

			# Iterate through the list of remaining numbers
			i = 0
			while i < len(shortListOfNumbers):
				#debugM(None, shortListOfNumbers[i+index])
				# If the value found at the index plus the offset is
				# greater than the current max value, set the max value
				# to what is stored at that position.
				if int(shortListOfNumbers[i+index]) > maxVal:
					maxVal = int(shortListOfNumbers[i+index])
				# Increment the counter by 2 (to skip over 1 space).
				i += 2

	#debugM("maxVal", maxVal+1)

	# Return the variable.
	return maxVal+1


# Helper function that removes all instances of an item from a list.
# @param, targetlist: the list to be modified.
# @param, item: the item whose instance is to be completely removed
#	from targetlist.
# @return, returns the modified target list. 
def removeAll(targetList, item):
	# While the item still exists in the list, remove it.
	while item in targetList:
		targetList.remove(item)
	# Return the now modified list.
	return targetList


if __name__ == '__main__':
	main()
