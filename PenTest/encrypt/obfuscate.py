# obfuscate.py
# author: Diego Magdaleno
# This program breaks a file down into its characters and stores them
# in a dictionary where their values are a list of indices.
# Python 3.6
# Linux


import sys
import os


def main():
	# Variables to be set for operations.
	debug = False
	obfu = False
	clari = False
	numFiles = 0

	debugM("Outside of checking sys args.")

	# Check the cmd args to see if there is proper usage when running
	# the program.
	if not checkSysArgs():
		printErrorMsg()

	debugM("Sys args are valid. Going on to load options.")

	# Check the usage arguments and set operation variables.
	usage = sys.argv[1]
	if usage == "-h":
		printHelpMsg()
		exit(0)
	if "o" in usage:
		obfu = True
	if "c" in usage:
		clari = True
	if "d" in usage:
		debug = True
	options = [debug, obfu, clari]

	#debugM("")
	debugM("usage", usage)
	debugM("options", options)

	# Go file by file in the arguments, performing the appropriate
	# operations for each.
	numFiles = len(sys.argv) - 2
	debugM("Number of files", numFiles)
	for i in range(numFiles):
		file = sys.argv[2+i]
		debugM("File", file)
		operate(file, options)

	# Program is finished. Exit.
	exit(0)


# Check to make sure the proper starting arugments exist within the 
# cmd args.
# @param, takes no arguments.
# @return, returns a boolean (True) if all arguments are correct. False
#	otherwise.
def checkSysArgs():
	if len(sys.argv) < 3:
		return False
	elif "-" not in sys.argv[1]:
		return False
	elif "o" in sys.argv[1] and "c" in sys.argv[1]:
		return False
	elif "o" in sys.argv[1] and "h" in sys.argv[1]:
		return False
	elif "c" in sys.argv[1] and "h" in sys.argv[1]:
		return False
	elif "h" in sys.argv[1] and "d" in sys.argv[1]:
		return False
	return True


# Print an error message to the console. This is the default error
#	message. Program exits afterwards.
# @param, takes no arguments.
# @return, returns nothing.
def printErrorMsg():
	usageStr = "\'python obfuscate.py -h \'"
	print("Error: For proper usage of this program, type"+usageStr)
	exit(1)


# Print a message to help users understand how to use the program.
# @param, takes no arguments.
# @return, returns nothing.
def printHelpMsg():
	pass


# Perform the desired operation on a file.
# @param, file: the file that needs to be operated on.
# @param, options: a tuple that contains variables detailing the
# 	options of the operation.
# @return, returns nothing. 
def operate(file, options):
	# Check if file exists.
	if not fileExists(file):
		print("Error: File does not exist in current path.")
		return

	# Check debug flag in options.
	if options[0]:
		debugM("File exists")

	# Check the operations.
	if options[1] == True:
		if options[0]:
			debugM("Program selected obfuscate")
		# Enter obfuscation mode.
		obfuscate(file, options[0])
	elif options[2] == True:
		if options[0]:
			debugM("Program selected clarify")
		# Enter clarification mode.
		clarify(file, options[0])


# Checks if a path to a file exists.
# @param, file: the path string to a file.
# @return, returns a boolean (True) if the path leads to a file. False
#	otherwise.
def fileExists(file):
	return os.path.exists(file) and os.path.isfile(file)


# Re write the file so that it is encrypted.
# @param, file: the path string to a file.
# @param, debugFlag: the flag for whether debug mode is engaged or not.
# @return, returns nothing.
def obfuscate(file, debugFlag):
	# Open file and load its contents to memory.
	lines = load(file)
	if debugFlag:
		debugM("file contents", lines)

	# Create a dictionary variable.
	charDict = dict()

	# Iterate through each line. Store characters to dictionary along
	# with their positions.
	for i in range(len(lines)):
		line = lines[i]
		# Iterate through the entire line string.
		for j in range(len(line)):
			char = line[j]
			if char not in charDict.keys():
				charDict[char] = list()
				charDict[char].append([i, j])
			else:
				charDict[char].append([i, j])

	if debugFlag:
		debugM("Dictionary", charDict)

	# Write dictionary to contents list.
	contents = list()
	for k in charDict:
		contents.append([k, charDict[k]])

	if debugFlag:
		debugM("Writing contents", contents)

	# Open file and re write its contents.
	save(file, contents)


# Re write the file so that it is decrypted.
# @param, file: the path string to a file.
# @param, debugFlag: the flag for whether debug mode is engaged or not.
# @return, returns nothing.
def clarify(file, debugFlag):
	# Open file and load its contents to memory.
	lines = load(file)

	# Open file and re write its contents.
	save(file, content)


# Open file and load its contents to memory.
# @param, file: the path string to a file.
# @return, returns a list of lines that contains the files contents.
def load(file):
	openFile = open(file, "r")
	lines = openFile.readlines()
	openFile.close()
	return lines


# Open file and re write its contents.
# @param, file: the path string to a file.
# @param, contents: a list of lines that are to be written to the file.
# @return, returns nothing.
def save(file, contents):
	# Open file and iterathe through contents to be written.
	openFile = open(file, "w")
	for line in contents:
		debugM(None, line)
		# If the contents are lists (this is from obfuscation mode),
		# Then iterate through the list and write it to file.
		if isinstance(line, list):
			debugM("Writing list as line")
			for item in line:
				openFile.write(str(item))
				#print(item)
			openFile.write("\n")
		# Otherwise, the contents are reconstructed strings to be
		# written back to the file.
		else:
			debugM("Writing string in line")
			openFile.write(line)
	# Writing is complete, close file.
	openFile.close()
	debugM("File saved")


# A method handy for printing debug statements.
# @param, string: default is None. Holds the string that is to be
#	printed to console.
# @param, items: default is None. Holds the items that are to be
#	printed to the console.
# @return, returns nothing
def debugM(string=None, items=None):
	# Print a string if there is one.
	if string != None:
		print(string)
	# Print the items and their type is there is one.
	if items != None:
		print(type(items))
		print(items)
	# Print a newline character to console for spacing if at least
	# one of the arguments is not None.
	if string != None or items != None:
		print("\n")
	# Otherwise, print nothing.


if __name__ == '__main__':
	main()
