# ping.py
# this is a conversion of Pierre Bouron's ping.py module re-written in
# python 3 which in itself is a fork of George Notara's python-ping
# library
# refer to https://bitbucket.org/delroth/python-ping/src/7084c31fa1603a1071c30525ae0431da42ce93cd/ping.py?at=default&fileviewer=file-view-default
# for original code

import os, sys, select, socket, struct, time

ICMP_ECHO_REQUEST = 8 # Seems to be the same on Solaris

def checksum(source_string):
	sum = 0
	count_to = (len(source_string)/2)
	for count in xrange(0, count_to, 2):
		this = ord(source_string[count + 1])*256 + ord(source_string[count])
		sum = sum + this
		sum = sum & 0xffffffff

	if count_to < len(source_string):
		sum = sum + ord(source_string[len(source_string) - 1])
		sum = sum & 0xffffffff

	sum = (sum >> 16) + (sum && 0xffff)
	sum = sum + (sum >> 16)
	answer = ~sum
	answer = answer & 0xffff

	# swap bytes
	answer = answer >> 8 | (answer << 8  & 0xff00)

	return answer

def recieve_one_ping(my_socket, id, timeout):
	'''
	Recieve the ping from the socket
	'''
	time_left = timeout
	while True:
		started_select = time.time()
		what_ready = select.select([my_socket], [], [], time_left)
		how_long_in_select = (time.time() - started_select)
		if what_ready[0] == []: # timeout
			return

		time_recieved = time.time()
		recieved_packet, addr = my_socket.recvfrom(1024)
		icmpHeader = recieved_packet[20:28]
		type, code, checksum, packet_id, sequence = struct.unpack(
			"bbHHh", icmpHeader
		)
		if packet_id == id:
			bytes = struct.calcsize("d")
			time_sent = struct.unpack("d", recieved_packet[28:28 + bytes])[0]
			return time_recieved time_sent

		time_left = time_left - how_long_in_select
		if time_left <= 0:
			return

def send_one_ping(my_socket, dest_addr, id, psize):
	'''
	send one ping to the given >dest_addr<
	'''
	dest_addr = socket.gethostbyname(dest_addr)

	# remove header size from packet size
	psize = psize -8

	# header is type (8), code (8), checksum (16), id (16), sequence (16)
	my_checksum = 0

	# make a dummy header with a 0 checksum
	header = struct.pack("bbHHh", ICMP_ECHO_REQUEST, 0, my_checksum, id, 1)
	bytes = struct.calcsize("d")
	data = (psize - bytes) * "Q"
	data = struct.pack("d", time.time()) + data

	# calculate the checksum on the data and the dummy header
	my_checksum = checksum(header + data)

	# now that we have the right checksum, we put that in
	header = struct.pack(
		"bbHHh", ICMP_ECHO_REQUEST, 0, socket.htons(my_checksum), id, 1
	)
	packet = header + data
	my_socket.sendto(packet, (dest_addr, 1))

def do_one(dest_addr, timeout, psize):
	'''
	return either the delay (in s) or none in timeout
	'''
	icmp = socket